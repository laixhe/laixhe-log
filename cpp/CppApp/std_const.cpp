#include "std_const.h"

// 指向常量的指针 vs 指针常量
// 要理解复杂的 const 声明，请使用“向右看齐“法则：从变量名开始，先向右看，再向左看
//
//# 在 C语言 中
//
// 1. 外部文件可用，为外部连接
// 2. const 修饰全局变量为只读，内存空间在文字常量区(只读)，不能间接修改
// 3. const 修饰局部变量为只读，内存空间栈区(可读可写)，可间接修改
//
//# 在 cpp 中
//
// 1. 只作用于当前文件，为内部连接
// 2. 如果必须用在其它文件使用，那要加上 extern 修饰后就转换成了外接链接
// 3. 对于基础类型，系统不会创建空间，会放到符号表中 (如：const int data=10)
// 4. 是否为 const 常量分配内存空间，是要依赖于如何使用这个常量 (
//       如：仅仅使用值那么就不必创建内存
//           对一个 const 取地址或者把它定义为 extern 则会创建内存空间
//    )
// 5. 当以变量的形式对 const 修饰的变量初始化(如：const int a=b)，也会分配内存空间，当不会放到符号表中
// 6. 对于自定义数据类型，比如 类对象、结构体，那么也会分配内存

// 常量指针(锁数据，不锁指针)
void const_pointer(){
    int a = 10;
    int b = 20;
    // 向右：看到指针 * 说明 p 是一个指针
    // 向左：看到 const int 说明指向的是 const int
    // 结论：指向常量的指针（指针可改，指向的数据不可改）
    const int* p = &a;
    p = &b;     // OK: 可以修改指针本身
    // *p = 30; // Error: 不能修改指向的数据

    std::cout << *p << std::endl;
}

// 指针常量(锁指针，不锁数据)
void pointer_const(){
    int a = 10;
    int b = 20;
    // 向右：看到 const 说明 p 是常量
    // 向左：看到 int* 说明是一个整数指针
    // 结论：指针常量（指针不可改，指向的数据可改）
    int* const p = &a;
    //p = &b; // Error: 不能修改指针本身
    *p = 30; // OK: 可以修改指向的数据

    std::cout << *p << std::endl;
}

// 指向常量的指针常量(锁指针，锁数据)
void const_pointer_const(){
    int a = 10;
    int b = 20;
    // 向右：看到 const 说明 p 是常量
    // 向左：看到 const int*，说明是一个指向常量的指针
    // 结论：指向常量的指针常量（指针和指向的数据都不可改）
    const int* const p = &a;
    //p = &b; // Error: 不能修改指针本身
    // *p = 30; // Error: 不能修改指向的数据
}
